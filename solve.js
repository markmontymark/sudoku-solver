// Generated by CoffeeScript 1.6.2
(function() {
  var cell_length, exports, get_horizontal, get_idx, get_needs, get_nonzeros, get_row_n, get_square, get_squares, get_vertical, get_zeros, grid, grid_length, grid_to_string, grids, has, init_grid, is_solved, n_grid_cells, print_grid, reset_possibles, reset_test, set, solve, solve_1_missing, solve_by_h_v_sq, solve_loop, solve_w_possibles, solve_w_testing, start_test;

  grid = null;

  grids = [];

  n_grid_cells = 0;

  grid_length = 0;

  cell_length = 0;

  solve = function(content) {
    init_grid(content);
    solve_loop();
    return grid_to_string();
  };

  exports = typeof window !== "undefined" && window !== null ? window : root;

  window.solve = solve;

  is_solved = function() {
    var sq;

    return ((function() {
      var _i, _len, _ref, _results;

      _ref = get_squares();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sq = _ref[_i];
        if (has(0, sq)) {
          _results.push(0);
        }
      }
      return _results;
    })()).length === 0;
  };

  grid_to_string = function(g) {
    var cell, i, str, _i, _len;

    if (g == null) {
      g = grid;
    }
    i = -1;
    str = [];
    for (_i = 0, _len = g.length; _i < _len; _i++) {
      cell = g[_i];
      ++i;
      if ((i % grid_length) === 0) {
        str.push('\n');
      }
      if ((i % (grid_length * cell_length)) === 0) {
        str.push('\n');
      }
      str.push(cell.n + ' ');
      if ((((i + 1) % cell_length) === 0) && (i % grid_length) !== 0) {
        str.push('  ');
      }
    }
    str.push('\n');
    return str.join('');
  };

  print_grid = function() {
    return console.log(grid_to_string());
  };

  init_grid = function(lines) {
    var idx, n;

    idx = -1;
    grid = (function() {
      var _i, _len, _ref, _results;

      _ref = ("" + lines).split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (/\d/.test(n)) {
          _results.push({
            'n': parseInt(n),
            'idx': ++idx
          });
        }
      }
      return _results;
    })();
    grids = [];
    n_grid_cells = grid.length;
    grid_length = Math.sqrt(n_grid_cells);
    cell_length = Math.sqrt(grid_length);
    if (n_grid_cells !== Math.pow(Math.pow(cell_length, 2), 2)) {
      console.log("init_grid, error creating grid, grid doesnt seem to be square. got n_grid_cells " + n_grid_cells + ", cell_length " + cell_length + "\n");
      return print_grid();
    }
  };

  start_test = function() {
    var cell;

    return grids.push((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = grid.length; _i < _len; _i++) {
        cell = grid[_i];
        _results.push({
          n: cell.n,
          idx: cell.idx
        });
      }
      return _results;
    })());
  };

  reset_test = function() {
    return grid = grids.pop();
  };

  set = function(n, idx, m) {
    var fn, vs, _i, _len, _ref;

    idx = get_idx(idx);
    _ref = [[get_square, 's'], [get_vertical, 'v'], [get_horizontal, 'h']];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      fn = _ref[_i];
      vs = fn[0](idx);
      if (has(n, vs)) {
        return 0;
      }
    }
    return grid[idx].n = n;
  };

  get_idx = function(c) {
    if (typeof c === 'object') {
      return c['idx'];
    } else {
      return c;
    }
  };

  get_square = function(c) {
    var i, idx, j, local_origin, retval, x, _i, _j, _len, _ref, _ref1;

    idx = get_idx(c);
    local_origin = idx - ((get_row_n(idx) % cell_length) * grid_length) - (idx % cell_length);
    retval = [];
    _ref = (function() {
      var _j, _ref, _results;

      _results = [];
      for (i = _j = 0, _ref = cell_length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        _results.push(local_origin + (grid_length * i));
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      for (j = _j = 0, _ref1 = cell_length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        retval.push(grid[x + j]);
      }
    }
    return retval;
  };

  get_squares = function() {
    var i, j, l, local_origin, m, retval, _i, _j, _len, _len1, _ref;

    retval = [];
    _ref = (function() {
      var _j, _len, _ref, _results;

      _ref = (function() {
        var _k, _ref, _results1;

        _results1 = [];
        for (i = _k = 0, _ref = cell_length - 1; 0 <= _ref ? _k <= _ref : _k >= _ref; i = 0 <= _ref ? ++_k : --_k) {
          _results1.push(cell_length * grid_length * i);
        }
        return _results1;
      })();
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        local_origin = _ref[_j];
        _results.push((function() {
          var _k, _ref1, _results1;

          _results1 = [];
          for (j = _k = 0, _ref1 = cell_length - 1; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
            _results1.push(local_origin + (j * cell_length));
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      for (_j = 0, _len1 = l.length; _j < _len1; _j++) {
        m = l[_j];
        retval.push(get_square(m));
      }
    }
    return retval;
  };

  get_vertical = function(c) {
    var col, i, _i, _ref, _results;

    col = get_idx(c) % grid_length;
    _results = [];
    for (i = _i = 0, _ref = grid_length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(grid[col + (grid_length * i)]);
    }
    return _results;
  };

  get_horizontal = function(c) {
    var i, idx, row_start, _i, _ref, _results;

    idx = get_idx(c);
    row_start = idx - ((grid_length + idx) % grid_length);
    _results = [];
    for (i = _i = row_start, _ref = row_start + grid_length - 1; row_start <= _ref ? _i <= _ref : _i >= _ref; i = row_start <= _ref ? ++_i : --_i) {
      _results.push(grid[i]);
    }
    return _results;
  };

  get_row_n = function(c) {
    var i, idx;

    idx = get_idx(c);
    return ((function() {
      var _i, _results;

      _results = [];
      for (i = _i = 1; 1 <= grid_length ? _i <= grid_length : _i >= grid_length; i = 1 <= grid_length ? ++_i : --_i) {
        if (idx <= ((grid_length * i) - 1)) {
          _results.push(i - 1);
        }
      }
      return _results;
    })())[0];
  };

  get_needs = function(non_zeros) {
    var i, _i, _results;

    _results = [];
    for (i = _i = 1; 1 <= grid_length ? _i <= grid_length : _i >= grid_length; i = 1 <= grid_length ? ++_i : --_i) {
      if (!has(i, non_zeros)) {
        _results.push(i);
      }
    }
    return _results;
  };

  get_zeros = function(list) {
    var cell, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      cell = list[_i];
      if (cell.n === 0) {
        _results.push(cell);
      }
    }
    return _results;
  };

  get_nonzeros = function(list) {
    var cell, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      cell = list[_i];
      if (cell.n !== 0) {
        _results.push(cell);
      }
    }
    return _results;
  };

  has = function(n, list) {
    var cell;

    return ((function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        cell = list[_i];
        if ((n === cell) || ((typeof cell === "object") && (n === cell.n))) {
          _results.push(1);
        }
      }
      return _results;
    })())[0];
  };

  solve_1_missing = function() {
    var z;

    return ((function() {
      var _i, _len, _ref, _results;

      _ref = get_zeros(grid);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        z = _ref[_i];
        if (solve_by_h_v_sq(z)) {
          _results.push(1);
        }
      }
      return _results;
    })())[0];
  };

  solve_by_h_v_sq = function(z) {
    var needs;

    needs = get_needs(get_nonzeros(get_horizontal(z).concat(get_vertical(z)).concat(get_square(z))));
    return needs.length === 1 && set(needs[0], z, 'hvsq');
  };

  reset_possibles = function() {
    var alreadyHas, n, nonzs, z, _i, _len, _ref;

    _ref = get_zeros(grid);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      z = _ref[_i];
      nonzs = get_nonzeros(get_square(z));
      alreadyHas = nonzs.concat(get_nonzeros(get_horizontal(z))).concat(get_nonzeros(get_vertical(z)));
      z.possibles = (function() {
        var _j, _len1, _ref1, _results;

        _ref1 = get_needs(nonzs);
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (!has(n, alreadyHas)) {
            _results.push(n);
          }
        }
        return _results;
      })();
      if (z.possibles.length === 0) {
        return 1;
      }
    }
  };

  solve_w_possibles = function() {
    var has_other, need, needs, next_z, other_v_zs, other_vs, sq, vz, z, z_needs, zs, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;

    _ref = get_squares();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sq = _ref[_i];
      zs = get_zeros(sq);
      needs = get_needs(get_nonzeros(sq));
      for (_j = 0, _len1 = needs.length; _j < _len1; _j++) {
        need = needs[_j];
        z_needs = (function() {
          var _k, _len2, _results;

          _results = [];
          for (_k = 0, _len2 = zs.length; _k < _len2; _k++) {
            z = zs[_k];
            if (has(need, z.possibles)) {
              _results.push(z);
            }
          }
          return _results;
        })();
        if (z_needs.length === 1 && set(need, z_needs[0], 'swp1')) {
          continue;
        }
        for (_k = 0, _len2 = zs.length; _k < _len2; _k++) {
          z = zs[_k];
          if (!(!has(need, get_horizontal(z)))) {
            continue;
          }
          other_vs = get_vertical(z);
          if (has(need, other_vs)) {
            continue;
          }
          other_v_zs = get_zeros(other_vs);
          has_other = other_v_zs.length > 0;
          next_z = 0;
          for (_l = 0, _len3 = other_v_zs.length; _l < _len3; _l++) {
            vz = other_v_zs[_l];
            if ((next_z === 0) && (vz.idx !== z.idx) && has(need, vz.possibles)) {
              next_z = 1;
            }
          }
          if ((!(next_z === 1 || !has_other)) && set(need, z, 'swp2')) {
            return 1;
          }
        }
      }
    }
  };

  solve_w_testing = function() {
    var n, solved_it, sq, zs, _i, _j, _len, _len1, _ref, _ref1;

    _ref = get_squares();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sq = _ref[_i];
      zs = get_zeros(sq);
      if (!((zs != null) && (zs[0] != null))) {
        continue;
      }
      _ref1 = get_needs(get_nonzeros(sq));
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        n = _ref1[_j];
        start_test();
        if (set(n, zs[0], 'swt')) {
          solve_loop();
        }
        solved_it = is_solved();
        if (!solved_it) {
          reset_test();
        }
        if (solved_it) {
          return 1;
        }
      }
    }
  };

  solve_loop = function() {
    while (!is_solved()) {
      if (solve_1_missing()) {
        continue;
      }
      if (reset_possibles()) {
        return;
      }
      if (solve_w_possibles()) {
        continue;
      }
      solve_w_testing();
      return;
    }
  };

}).call(this);
